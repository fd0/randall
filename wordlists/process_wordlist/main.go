package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
	"text/template"
	"unicode/utf8"

	"github.com/spf13/pflag"
)

const (
	allowedChars         = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZöäüÖÄÜß"
	specialChars         = `"'-./ 0123456789`
	defaultMinCharacters = 3
	defaultMaxCharacters = 19
	defaultMinWords      = 7776
)

func check(word string, minCharacters uint, maxCharacters uint) error {
	if !utf8.ValidString(word) {
		return fmt.Errorf("not a valid UTF-8 string")
	}

	// note: range over string iterates over runes (decoding UTF-8 characters)
	var runes uint
	for _, r := range word {
		if r == utf8.RuneError {
			return fmt.Errorf("contains error rune")
		}

		if !strings.ContainsAny(allowedChars, string(r)) {
			return fmt.Errorf("character %s is not an allowed character (%s)", string(r), allowedChars)
		}

		runes++
	}

	if runes < minCharacters {
		return fmt.Errorf("length %d is shorter than %d characters", runes, minCharacters)
	}

	if runes > maxCharacters {
		return fmt.Errorf("length %d is longer than %d characters", runes, maxCharacters)
	}

	// filter special characters
	if strings.ContainsAny(word, specialChars) {
		return fmt.Errorf("contains special characters (%s)", specialChars)
	}

	return nil
}

// for the format of the "do not edit" string see https://golang.org/s/generatedcode
const listTemplate = `// Code generated by process_wordlist; DO NOT EDIT.

package wordlists

func init() {
Lists[{{ printf "%q" .Name }}] = []string{
{{range .Words }}
{{- printf "%q" . }},
{{end}}
}
}
`

func readFiles(minWords uint, minCharacters uint, maxCharacters uint, files ...string) (words []string, err error) {
	for _, filename := range files {
		f, err := os.Open(filename)
		if err != nil {
			return nil, err
		}

		defer f.Close()

		sc := bufio.NewScanner(f)
		for sc.Scan() {
			if sc.Err() != nil {
				return nil, sc.Err()
			}

			data := strings.Fields(sc.Text())
			word := data[len(data)-1]

			err := check(word, minCharacters, maxCharacters)
			if err != nil {
				return nil, fmt.Errorf("invalid word %q: %w", word, err)
			}

			words = append(words, word)
		}

		err = f.Close()
		if err != nil {
			return nil, err
		}
	}

	if len(words) < int(minWords) {
		return nil, fmt.Errorf("wordlist only contains %d words instead of a minimum of %d", len(words), minWords)
	}

	return words, nil
}

func run() error {
	var opts struct {
		output        string
		name          string
		minCharacters uint
		maxCharacters uint
		minWords      uint
	}

	flags := pflag.NewFlagSet("process", pflag.ExitOnError)
	flags.StringVar(&opts.output, "output", "", "write output to `file`")
	flags.StringVar(&opts.name, "name", "", "set wordlist `name`")
	flags.UintVar(&opts.minWords, "min-words", defaultMinWords, "minimum number of words")
	flags.UintVar(&opts.minCharacters, "min-chars", defaultMinCharacters, "minimum number of characters")
	flags.UintVar(&opts.maxCharacters, "max-chars", defaultMaxCharacters, "maximum number of characters")
	flags.SortFlags = false

	err := flags.Parse(os.Args)
	if err != nil {
		return fmt.Errorf("parse flags: %w", err)
	}

	if flags.NArg() < 2 {
		return fmt.Errorf("specify input files as positional arguments")
	}

	if opts.output == "" {
		return fmt.Errorf("output file unset, use --output FILE")
	}

	if opts.name == "" {
		return fmt.Errorf("name not set, use --name X")
	}

	tmpl, err := template.New("").Parse(listTemplate)
	if err != nil {
		return fmt.Errorf("parse template: %w", err)
	}

	words, err := readFiles(opts.minWords, opts.minCharacters, opts.maxCharacters, flags.Args()[1:]...)
	if err != nil {
		return fmt.Errorf("read files: %w", err)
	}

	buf := &bytes.Buffer{}

	err = tmpl.Execute(buf, struct {
		Name  string
		Words []string
	}{
		Name:  opts.name,
		Words: words,
	})
	if err != nil {
		return fmt.Errorf("execute template: %w", err)
	}

	generatedCode, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format generated code: %w", err)
	}

	err = os.WriteFile(opts.output, generatedCode, 0o644)
	if err != nil {
		return fmt.Errorf("write output: %w", err)
	}

	return nil
}

func main() {
	err := run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)

		os.Exit(1)
	}
}
